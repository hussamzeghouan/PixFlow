<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PixFlow Pattern Generator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f0f0f0;
    }
    h1 {
      text-align: center;
      color: #333;
    }
    .container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    .controls {
      flex: 1;
      min-width: 300px;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .preview {
      flex: 2;
      min-width: 400px;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .control-group {
      margin-bottom: 15px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    input[type="number"], input[type="color"], select {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .checkboxes label {
      display: inline-flex;
      align-items: center;
      margin-right: 10px;
      font-weight: normal;
      cursor: pointer;
      padding: 5px 10px;
      border-radius: 20px;
      background: #eee;
      transition: all 0.2s;
    }
    .checkboxes label.active {
      background: #4CAF50;
      color: white;
    }
    .checkboxes input[type="checkbox"] {
      margin-right: 5px;
    }
    .settings-panel {
      background: #f9f9f9;
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
      display: none;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
      font-size: 16px;
      width: 100%;
    }
    button:hover {
      background: #45a049;
    }
    .color-palette {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 10px;
    }
    .color {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
    }
    .color.active {
      border-color: #333;
      transform: scale(1.1);
    }
    .actions {
      margin-top: 20px;
      display: flex;
      gap: 10px;
    }
    .actions button {
      flex: 1;
    }
    #fillPercentLabel, #cornerRadiusLabel {
      display: inline-block;
      width: 30px;
      text-align: center;
    }
    #grid {
      border: 1px solid #ddd;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h1>PixFlow Pattern Generator</h1>
  
  <div class="container">
    <div class="controls">
      <div class="control-group">
        <label for="columns">Columns:</label>
        <input type="number" id="columns" value="10" min="1" max="50">
        
        <label for="rows">Rows:</label>
        <input type="number" id="rows" value="10" min="1" max="50">
        
        <label for="cellWidth">Cell Width (px):</label>
        <input type="number" id="cellWidth" value="40" min="10" max="200">
        
        <label for="cellHeight">Cell Height (px):</label>
        <input type="number" id="cellHeight" value="40" min="10" max="200">
      </div>
      
      <div class="control-group">
        <label for="fillColor">Primary Color:</label>
        <input type="color" id="fillColor" value="#ff6666">
        
        <label for="secondaryColor">Secondary Color:</label>
        <input type="color" id="secondaryColor" value="#66aaff">
        
        <label for="bgColor">Background Color:</label>
        <input type="color" id="bgColor" value="#ffffff">
      </div>
      
      <div class="control-group">
        <label for="fillPercent">Fill Percentage: <span id="fillPercentLabel">50</span>%</label>
        <input type="range" id="fillPercent" min="0" max="100" value="50" oninput="updatePercentLabel(this.value)">
      </div>
      
      <div class="control-group checkboxes">
        <label class="toggle"><input type="checkbox" id="randomSize"> Random Size</label>
        <label class="toggle"><input type="checkbox" id="roundedCorners"> Rounded</label>
        <label class="toggle"><input type="checkbox" id="multiColor"> Multi-Color</label>
        <label class="toggle"><input type="checkbox" id="applyShear"> Shear</label>
        <label class="toggle"><input type="checkbox" id="gradientFill"> Gradient</label>
      </div>
      
      <!-- Rounded Corners Settings -->
      <div id="roundedCornersSettings" class="settings-panel">
        <label for="cornerRadius">Corner Radius: <span id="cornerRadiusLabel">10</span>%</label>
        <input type="range" id="cornerRadius" min="0" max="100" value="10" oninput="updateCornerLabel(this.value)">
      </div>
      
      <!-- Multi-Color Settings -->
      <div id="multiColorSettings" class="settings-panel">
        <label>Color Palette:</label>
        <div class="color-palette">
          <div class="color active" data-color="#ff6666" style="background-color: #ff6666;"></div>
          <div class="color" data-color="#66aaff" style="background-color: #66aaff;"></div>
          <div class="color" data-color="#66ff66" style="background-color: #66ff66;"></div>
          <div class="color" data-color="#ffff66" style="background-color: #ffff66;"></div>
          <div class="color" data-color="#ff66ff" style="background-color: #ff66ff;"></div>
        </div>
      </div>
      
      <!-- Gradient Settings -->
      <div id="gradientSettings" class="settings-panel">
        <label for="gradientStart">Gradient Start:</label>
        <input type="color" id="gradientStart" value="#ff6666">
        
        <label for="gradientEnd">Gradient End:</label>
        <input type="color" id="gradientEnd" value="#66aaff">
        
        <label for="gradientDirection">Direction:</label>
        <select id="gradientDirection">
          <option value="horizontal">Horizontal</option>
          <option value="vertical">Vertical</option>
          <option value="diagonal">Diagonal</option>
          <option value="radial">Radial</option>
        </select>
      </div>
      
      <button onclick="generateGrid()">Generate Pattern</button>
      
      <div class="actions">
        <button onclick="exportSVG()">Export SVG</button>
        <button onclick="exportPNG()">Export PNG</button>
      </div>
    </div>
    
    <div class="preview">
      <h2>Preview</h2>
      <svg id="grid" width="400" height="400" viewBox="0 0 400 400"></svg>
    </div>
  </div>

  <script>
    // Update labels for sliders
    function updatePercentLabel(value) {
      document.getElementById('fillPercentLabel').textContent = value;
    }
    
    function updateCornerLabel(value) {
      document.getElementById('cornerRadiusLabel').textContent = value;
    }
    
    // The fixed function that should correct the blank canvas issue
    function generateGrid() {
      const svg = document.getElementById('grid');
      svg.innerHTML = '';
      
      // Get all the settings
      const cellWidth = parseInt(document.getElementById('cellWidth').value) || 40;
      const cellHeight = parseInt(document.getElementById('cellHeight').value) || 40;
      const columns = parseInt(document.getElementById('columns').value) || 10;
      const rows = parseInt(document.getElementById('rows').value) || 10;
      const fillColor = document.getElementById('fillColor').value;
      const secondaryColor = document.getElementById('secondaryColor').value;
      const bgColor = document.getElementById('bgColor').value;
      const fillPercent = parseInt(document.getElementById('fillPercent').value) || 50;
      
      // Feature toggles
      const randomSize = document.getElementById('randomSize').checked;
      const roundedCorners = document.getElementById('roundedCorners').checked;
      const multiColor = document.getElementById('multiColor').checked;
      const applyShear = document.getElementById('applyShear').checked;
      const gradientFill = document.getElementById('gradientFill').checked;
      
      // Additional settings
      const cornerRadius = parseInt(document.getElementById('cornerRadius').value) || 10;
      const gradientStart = document.getElementById('gradientStart')?.value || '#ff6666';
      const gradientEnd = document.getElementById('gradientEnd')?.value || '#66aaff';
      const gradientDirection = document.getElementById('gradientDirection')?.value || 'horizontal';
      
      // Set SVG dimensions and background
      const totalWidth = columns * cellWidth;
      const totalHeight = rows * cellHeight;
      
      svg.setAttribute('width', totalWidth);
      svg.setAttribute('height', totalHeight);
      svg.setAttribute('viewBox', `0 0 ${totalWidth} ${totalHeight}`);
      svg.style.background = bgColor;
      
      // Create a background rectangle to ensure the SVG has the proper dimensions and background
      const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      bgRect.setAttribute('width', totalWidth);
      bgRect.setAttribute('height', totalHeight);
      bgRect.setAttribute('fill', bgColor);
      svg.appendChild(bgRect);
      
      // If using gradient, define the gradients
      if (gradientFill) {
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        svg.appendChild(defs);
        
        const gradient = document.createElementNS('http://www.w3.org/2000/svg', 
                         gradientDirection === 'radial' ? 'radialGradient' : 'linearGradient');
        gradient.setAttribute('id', 'cellGradient');
        
        if (gradientDirection !== 'radial') {
          // Set gradient direction
          switch(gradientDirection) {
            case 'horizontal':
              gradient.setAttribute('x1', '0%');
              gradient.setAttribute('y1', '50%');
              gradient.setAttribute('x2', '100%');
              gradient.setAttribute('y2', '50%');
              break;
            case 'vertical':
              gradient.setAttribute('x1', '50%');
              gradient.setAttribute('y1', '0%');
              gradient.setAttribute('x2', '50%');
              gradient.setAttribute('y2', '100%');
              break;
            case 'diagonal':
              gradient.setAttribute('x1', '0%');
              gradient.setAttribute('y1', '0%');
              gradient.setAttribute('x2', '100%');
              gradient.setAttribute('y2', '100%');
              break;
          }
        }
        
        // Add stops
        const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', gradientStart);
        
        const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', gradientEnd);
        
        gradient.appendChild(stop1);
        gradient.appendChild(stop2);
        defs.appendChild(gradient);
      }
      
      // Get available colors if using multiColor
      let colors = [];
      if (multiColor) {
        document.querySelectorAll('.color').forEach(color => {
          const dataColor = color.getAttribute('data-color');
          if (dataColor) {
            colors.push(dataColor);
          }
        });
        
        // If no colors found in the palette, use default colors
        if (colors.length === 0) {
          colors = ['#ff6666', '#66aaff', '#66ff66', '#ffff66', '#ff66ff'];
        }
      }
      
      // Generate the grid cells
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < columns; x++) {
          // Apply fill percentage - skip some cells randomly
          if (Math.random() * 100 > fillPercent) continue;
          
          let width = cellWidth;
          let height = cellHeight;
          
          if (randomSize) {
            width = cellWidth * (0.5 + Math.random());
            height = cellHeight * (0.5 + Math.random());
          }
          
          // Determine cell color
          let color = fillColor;
          if (multiColor && colors.length > 0) {
            color = colors[Math.floor(Math.random() * colors.length)];
          }
          
          // Create the rectangle
          const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          rect.setAttribute('x', x * cellWidth);
          rect.setAttribute('y', y * cellHeight);
          rect.setAttribute('width', width);
          rect.setAttribute('height', height);
          
          // Apply fill color or gradient
          if (gradientFill) {
            rect.setAttribute('fill', 'url(#cellGradient)');
          } else {
            rect.setAttribute('fill', color);
          }
          
          // Apply rounded corners if enabled
          if (roundedCorners) {
            const rx = (cornerRadius/100) * (width/2);
            const ry = (cornerRadius/100) * (height/2);
            rect.setAttribute('rx', rx);
            rect.setAttribute('ry', ry);
          }
          
          // Apply shearing if enabled
          if (applyShear) {
            const skewX = Math.random() * 20 - 10;
            const skewY = Math.random() * 20 - 10;
            rect.setAttribute('transform', `skewX(${skewX}) skewY(${skewY})`);
          }
          
          svg.appendChild(rect);
        }
      }
      
      // Debug info to console
      console.log(`Generated grid: ${columns}x${rows} cells of ${cellWidth}x${cellHeight}px`);
      console.log(`Total size: ${totalWidth}x${totalHeight}px`);
      console.log(`Fill percentage: ${fillPercent}%`);
    }

    // This function helps with exporting the SVG
    function exportSVG() {
      const svg = document.getElementById('grid');
      
      // Ensure the SVG has the correct namespace
      if (!svg.getAttribute('xmlns')) {
        svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      }
      
      const serializer = new XMLSerializer();
      const source = serializer.serializeToString(svg);
      const blob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'pixflow-pattern.svg';
      link.click();
      
      // Clean up
      setTimeout(() => {
        URL.revokeObjectURL(url);
      }, 100);
    }

    // This function corrects the PNG export
    function exportPNG() {
      const svg = document.getElementById('grid');
      
      // Ensure the SVG has the correct namespace
      if (!svg.getAttribute('xmlns')) {
        svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      }
      
      const svgWidth = parseInt(svg.getAttribute('width'));
      const svgHeight = parseInt(svg.getAttribute('height'));
      
      const serializer = new XMLSerializer();
      const source = serializer.serializeToString(svg);
      const svgBlob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(svgBlob);
      
      const img = new Image();
      img.onload = function() {
        const canvas = document.createElement('canvas');
        canvas.width = svgWidth;
        canvas.height = svgHeight;
        
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = document.getElementById('bgColor').value;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
        
        // Clean up the URL
        URL.revokeObjectURL(url);

        // Download the PNG
        const pngUrl = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = pngUrl;
        link.download = 'pixflow-pattern.png';
        link.click();
      };
      
      // Handle any errors that might occur when loading the image
      img.onerror = function() {
        console.error('Error loading SVG for PNG export');
        URL.revokeObjectURL(url);
        alert('Failed to export PNG. Please try again.');
      };
      
      img.src = url;
    }

    // Make sure this runs on page load
    window.onload = function() {
      // Initialize labels
      updatePercentLabel(document.getElementById('fillPercent').value);
      if (document.getElementById('cornerRadius')) {
        updateCornerLabel(document.getElementById('cornerRadius').value);
      }
      
      // Set up checkbox event listeners
      document.querySelectorAll('.checkboxes input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
          const label = this.parentElement;
          if (this.checked) {
            label.classList.add('active');
          } else {
            label.classList.remove('active');
          }
          
          // For settings panels
          if (this.id === 'roundedCorners') {
            const panel = document.getElementById('roundedCornersSettings');
            if (panel) panel.style.display = this.checked ? 'block' : 'none';
          } else if (this.id === 'multiColor') {
            const panel = document.getElementById('multiColorSettings');
            if (panel) panel.style.display = this.checked ? 'block' : 'none';
          } else if (this.id === 'gradientFill') {
            const panel = document.getElementById('gradientSettings');
            if (panel) panel.style.display = this.checked ? 'block' : 'none';
          }
        });
      });
      
      // Set up color palette interactions
      document.querySelectorAll('.color').forEach(color => {
        color.addEventListener('click', function() {
          document.querySelectorAll('.color').forEach(c => c.classList.remove('active'));
          this.classList.add('active');
          const fillColorInput = document.getElementById('fillColor');
          if (fillColorInput) {
            fillColorInput.value = this.getAttribute('data-color');
          }
        });
      });
      
      // Generate initial grid
      generateGrid();
      
      // Log that initialization is complete
      console.log('PixFlow initialized successfully');
    };
  </script>
</body>
</html>
