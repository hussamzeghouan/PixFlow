<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PixFlow - Enhanced</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

  <style>
    :root {
      --primary: #18A0FB;
      --primary-hover: #0d8ae2;
      --background: #121212;
      --card-bg: #1e1e1e;
      --text: #f5f5f5;
      --text-secondary: #bbb;
      --input-bg: #2b2b2b;
      --border: #333;
    }
    body {
      margin: 0;
      padding: 30px;
      background: var(--background);
      font-family: 'Inter', sans-serif;
      color: var(--text);
    }
    h1 {
      font-size: 48px;
      margin-bottom: 5px;
      text-align: center;
      background: linear-gradient(90deg, #18A0FB, #8A2BE2);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 3px 10px rgba(24, 160, 251, 0.3);
    }
    .tagline {
      font-size: 18px;
      color: var(--text-secondary);
      margin-bottom: 30px;
      text-align: center;
    }
    .container {
      max-width: 1200px;
      margin: auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .card {
      background: var(--card-bg);
      padding: 25px;
      border-radius: 16px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
      transition: all 0.3s ease;
    }
    .card:hover {
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.5);
      transform: translateY(-2px);
    }
    .card-header {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
    }
    .card-header i {
      font-size: 20px;
      margin-right: 10px;
      color: var(--primary);
    }
    .card-header h2 {
      margin: 0;
      font-size: 20px;
    }
    .controls-container {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
    }
    .control-group {
      flex: 1;
      min-width: 280px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.15);
      border-radius: 12px;
    }
    .control-group h3 {
      margin-top: 0;
      margin-bottom: 15px;
      font-size: 16px;
      color: var(--primary);
      display: flex;
      align-items: center;
    }
    .control-group h3 i {
      margin-right: 8px;
    }
    .controls, .checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: flex-start;
    }
    .controls label, .checkboxes label {
      display: flex;
      flex-direction: column;
      font-size: 14px;
      width: 120px;
    }
    input[type="number"], input[type="range"] {
      padding: 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--input-bg);
      color: #fff;
      width: 100%;
      transition: all 0.2s;
    }
    input[type="number"]:focus, input[type="range"]:focus {
      border-color: var(--primary);
      outline: none;
      box-shadow: 0 0 0 2px rgba(24, 160, 251, 0.2);
    }
    input[type="color"] {
      width: 100%;
      height: 40px;
      padding: 5px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--input-bg);
      appearance: none;
      -webkit-appearance: none;
      cursor: pointer;
    }
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 8px;
      background: var(--input-bg);
      border-radius: 4px;
      outline: none;
      padding: 0;
      margin: 0;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      margin-top: -6px;
      box-shadow: 0 0 5px rgba(24, 160, 251, 0.5);
    }
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      box-shadow: 0 0 5px rgba(24, 160, 251, 0.5);
    }
    .checkboxes label {
      flex-direction: row;
      align-items: center;
      gap: 10px;
      width: auto;
      cursor: pointer;
      padding: 8px 15px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      transition: all 0.2s;
    }
    .checkboxes label:hover {
      background: rgba(24, 160, 251, 0.1);
    }
    .checkboxes label.active {
      background: rgba(24, 160, 251, 0.15);
    }
    .checkboxes i {
      color: var(--text-secondary);
      font-size: 18px;
    }
    .btn-container {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
    }
    button {
      background-color: var(--primary);
      color: white;
      padding: 12px 25px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.3s;
    }
    button:hover {
      background-color: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(24, 160, 251, 0.3);
    }
    button i {
      font-size: 18px;
    }
    #grid-container {
      display: flex;
      justify-content: center;
      margin: 20px 0;
    }
    #grid {
      margin: 20px auto;
      background: #1a1a1a;
      border: 1px solid var(--border);
      border-radius: 12px;
      display: block;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
    }
    .settings-panel {
      margin-top: 15px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.15);
      border-radius: 12px;
      display: none;
    }
    footer {
      margin-top: 40px;
      color: #888;
      font-size: 14px;
      text-align: center;
      padding: 20px 0;
    }
    footer a {
      color: #888;
      margin: 0 10px;
      font-size: 24px;
      text-decoration: none;
      transition: color 0.2s;
    }
    footer a:hover {
      color: var(--primary);
    }
    .color-palette {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 15px;
    }
    .color {
      width: 30px;
      height: 30px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      border: 2px solid transparent;
    }
    .color:hover {
      transform: scale(1.1);
    }
    .color.active {
      border-color: white;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
    }
    .hidden {
      display: none;
    }
    .flex-between {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .preset-select {
      padding: 10px;
      background: var(--input-bg);
      color: white;
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
    }
    .preset-select:focus {
      outline: none;
      border-color: var(--primary);
    }
  </style>
</head>

<body>

<h1>PixFlow</h1>
<p class="tagline">Advanced Pixel Pattern Generator</p>

<div class="container">
  <!-- Main Controls Card -->
  <div class="card">
    <div class="card-header">
      <i class="fas fa-sliders"></i>
      <h2>Pattern Settings</h2>
    </div>
    
    <div class="controls-container">
      <!-- Grid Controls -->
      <div class="control-group">
        <h3><i class="fas fa-th"></i> Grid Dimensions</h3>
        <div class="controls">
          <label title="Cell Width in pixels">
            Cell Width
            <input type="number" id="cellWidth" value="40" min="5" max="200">
          </label>
          <label title="Cell Height in pixels">
            Cell Height
            <input type="number" id="cellHeight" value="40" min="5" max="200">
          </label>
          <label title="Number of Columns">
            Columns
            <input type="number" id="columns" value="10" min="1" max="50">
          </label>
          <label title="Number of Rows">
            Rows
            <input type="number" id="rows" value="10" min="1" max="50">
          </label>
        </div>
      </div>
      
      <!-- Color Controls -->
      <div class="control-group">
        <h3><i class="fas fa-palette"></i> Color Settings</h3>
        <div class="controls">
          <label title="Fill Color for cells">
            Fill Color
            <input type="color" id="fillColor" value="#ff6666">
          </label>
          <label title="Background Color">
            Background
            <input type="color" id="bgColor" value="#121212">
          </label>
          <label title="Secondary Color for patterns">
            Secondary
            <input type="color" id="secondaryColor" value="#66aaff">
          </label>
          <label title="Fill Percentage">
            Fill %
            <input type="range" id="fillPercent" min="0" max="100" value="50" oninput="updatePercentLabel(this.value)">
            <span id="percentLabel">50%</span>
          </label>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Style Controls Card -->
  <div class="card">
    <div class="card-header">
      <i class="fas fa-brush"></i>
      <h2>Pattern Style</h2>
    </div>
    
    <div class="checkboxes">
      <label title="Generate cells with random sizes" id="randomSizeLabel">
        <input type="checkbox" id="randomSize"> <i class="fas fa-dice"></i> Random Size
      </label>
      <label title="Apply rounded corners to cells" id="roundedCornersLabel">
        <input type="checkbox" id="roundedCorners" onchange="toggleSettings('roundedCornersSettings')"> 
        <i class="fas fa-circle"></i> Rounded Corners
      </label>
      <label title="Use multiple colors" id="multiColorLabel">
        <input type="checkbox" id="multiColor" onchange="toggleSettings('multiColorSettings')"> 
        <i class="fas fa-palette"></i> Multi-Color
      </label>
      <label title="Apply shearing effect" id="applyShearLabel">
        <input type="checkbox" id="applyShear"> 
        <i class="fas fa-wave-square"></i> Shear
      </label>
      <label title="Create patterns with gradients" id="gradientFillLabel">
        <input type="checkbox" id="gradientFill" onchange="toggleSettings('gradientSettings')"> 
        <i class="fas fa-paint-roller"></i> Gradient
      </label>
    </div>
    
    <!-- Rounded Corners Settings -->
    <div id="roundedCornersSettings" class="settings-panel">
      <label title="Corner Radius Percentage">
        Corner Radius %
        <input type="range" id="cornerRadius" min="0" max="50" value="10" oninput="updateCornerLabel(this.value)">
        <span id="cornerLabel">10%</span>
      </label>
    </div>
    
    <!-- Multi-Color Settings -->
    <div id="multiColorSettings" class="settings-panel">
      <div class="flex-between">
        <h3>Color Palette</h3>
        <select id="colorPreset" class="preset-select" onchange="applyColorPreset()">
          <option value="custom">Custom</option>
          <option value="retro">Retro Vibes</option>
          <option value="ocean">Ocean Depths</option>
          <option value="sunset">Sunset Glow</option>
          <option value="forest">Forest Tones</option>
        </select>
      </div>
      <div class="color-palette" id="colorPalette">
        <div class="color active" style="background-color: #ff6666;" data-color="#ff6666"></div>
        <div class="color" style="background-color: #66aaff;" data-color="#66aaff"></div>
        <div class="color" style="background-color: #66ff66;" data-color="#66ff66"></div>
        <div class="color" style="background-color: #ffff66;" data-color="#ffff66"></div>
        <div class="color" style="background-color: #ff66ff;" data-color="#ff66ff"></div>
      </div>
    </div>
    
    <!-- Gradient Settings -->
    <div id="gradientSettings" class="settings-panel">
      <div class="controls">
        <label title="Start Color">
          Start Color
          <input type="color" id="gradientStart" value="#ff6666">
        </label>
        <label title="End Color">
          End Color
          <input type="color" id="gradientEnd" value="#66aaff">
        </label>
        <label title="Gradient Type">
          Direction
          <select id="gradientDirection" class="preset-select">
            <option value="horizontal">Horizontal</option>
            <option value="vertical">Vertical</option>
            <option value="diagonal">Diagonal</option>
            <option value="radial">Radial</option>
          </select>
        </label>
      </div>
    </div>
  </div>
  
  <!-- Actions Card -->
  <div class="card">
    <div class="btn-container">
      <button onclick="generateGrid()"><i class="fas fa-magic"></i> Generate Pattern</button>
      <button onclick="exportSVG()"><i class="fas fa-file-code"></i> Export SVG</button>
      <button onclick="exportPNG()"><i class="fas fa-file-image"></i> Export PNG</button>
      <button onclick="randomizeAll()"><i class="fas fa-random"></i> Randomize All</button>
    </div>
  </div>

  <!-- Grid Display -->
  <div id="grid-container">
    <svg id="grid" width="800" height="800"></svg>
  </div>
</div>

<footer>
  Designed with ❤️ — for all creative minds<br><br>
  <small>Created by <strong>Hussam Zeghouan</strong> | Enhanced Version</small><br><br>
  <a href="https://instagram.com/hsm_ze" target="_blank"><i class="fab fa-instagram"></i></a>
  <a href="https://behance.net/hsm_ze" target="_blank"><i class="fab fa-behance"></i></a>
  <a href="https://linktr.ee/hsm_ze" target="_blank"><i class="fas fa-link"></i></a>
</footer>

<script>
// Update label functions
function updatePercentLabel(value) {
  document.getElementById('percentLabel').innerText = value + '%';
}

function updateCornerLabel(value) {
  document.getElementById('cornerLabel').innerText = value + '%';
}

// Toggle settings panels
function toggleSettings(panelId) {
  const panel = document.getElementById(panelId);
  const isVisible = panel.style.display === 'block';
  panel.style.display = isVisible ? 'none' : 'block';
  
  // If this is the checkbox being toggled, update its label class
  const checkboxId = panelId.replace('Settings', '');
  const label = document.getElementById(checkboxId + 'Label');
  if (label) {
    if (isVisible) {
      label.classList.remove('active');
    } else {
      label.classList.add('active');
    }
  }
}

// Handle checkbox label highlighting
document.querySelectorAll('.checkboxes input[type="checkbox"]').forEach(checkbox => {
  checkbox.addEventListener('change', function() {
    const label = this.parentElement;
    if (this.checked) {
      label.classList.add('active');
    } else {
      label.classList.remove('active');
    }
  });
});

// Color palette selection
document.querySelectorAll('.color').forEach(color => {
  color.addEventListener('click', function() {
    document.querySelectorAll('.color').forEach(c => c.classList.remove('active'));
    this.classList.add('active');
    document.getElementById('fillColor').value = this.getAttribute('data-color');
  });
});

// Color presets
function applyColorPreset() {
  const preset = document.getElementById('colorPreset').value;
  const palette = document.getElementById('colorPalette');
  palette.innerHTML = '';
  
  let colors = [];
  
  switch(preset) {
    case 'retro':
      colors = ['#FF6B6B', '#4ECDC4', '#F9D423', '#FF4E50', '#556270'];
      break;
    case 'ocean':
      colors = ['#1A535C', '#4ECDC4', '#F7FFF7', '#2B7A78', '#DEF2F1'];
      break;
    case 'sunset':
      colors = ['#F9C80E', '#FF4365', '#5B2E5F', '#F15946', '#2C0835'];
      break;
    case 'forest':
      colors = ['#2D3047', '#93B7BE', '#E0CA3C', '#A37B45', '#3A5311'];
      break;
    default:
      colors = ['#ff6666', '#66aaff', '#66ff66', '#ffff66', '#ff66ff'];
  }
  
  colors.forEach(color => {
    const div = document.createElement('div');
    div.className = 'color';
    div.style.backgroundColor = color;
    div.setAttribute('data-color', color);
    div.addEventListener('click', function() {
      document.querySelectorAll('.color').forEach(c => c.classList.remove('active'));
      this.classList.add('active');
      document.getElementById('fillColor').value = this.getAttribute('data-color');
    });
    palette.appendChild(div);
  });
  
  // Set the first color as active
  palette.firstChild.classList.add('active');
  document.getElementById('fillColor').value = colors[0];
}

// Random all settings
function randomizeAll() {
  // Randomize dimensions
  document.getElementById('cellWidth').value = Math.floor(Math.random() * 45) + 15;
  document.getElementById('cellHeight').value = Math.floor(Math.random() * 45) + 15;
  document.getElementById('columns').value = Math.floor(Math.random() * 15) + 5;
  document.getElementById('rows').value = Math.floor(Math.random() * 15) + 5;
  
  // Randomize fill percent
  const fillPercent = Math.floor(Math.random() * 80) + 20;
  document.getElementById('fillPercent').value = fillPercent;
  updatePercentLabel(fillPercent);
  
  // Randomize colors
  document.getElementById('fillColor').value = getRandomColor();
  document.getElementById('secondaryColor').value = getRandomColor();
  document.getElementById('bgColor').value = getRandomColor(true);
  
  // Randomize features
  document.getElementById('randomSize').checked = Math.random() > 0.5;
  document.getElementById('roundedCorners').checked = Math.random() > 0.5;
  document.getElementById('multiColor').checked = Math.random() > 0.5;
  document.getElementById('applyShear').checked = Math.random() > 0.5;
  document.getElementById('gradientFill').checked = Math.random() > 0.5;
  
  // Update settings panels
  toggleSettings('roundedCornersSettings');
  toggleSettings('multiColorSettings');
  toggleSettings('gradientSettings');
  
  // Update UI state
  document.querySelectorAll('.checkboxes input[type="checkbox"]').forEach(checkbox => {
    const label = checkbox.parentElement;
    if (checkbox.checked) {
      label.classList.add('active');
    } else {
      label.classList.remove('active');
    }
  });
  
  // Generate the grid
  generateGrid();
}

function getRandomColor(dark = false) {
  if (dark) {
    // Generate darker colors for background
    return '#' + Math.floor(Math.random() * 0x444444).toString(16).padStart(6, '0');
  }
  return '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
}

function generateGrid() {
  const svg = document.getElementById('grid');
  svg.innerHTML = '';
  
  // Get all the settings
  const cellWidth = parseInt(document.getElementById('cellWidth').value);
  const cellHeight = parseInt(document.getElementById('cellHeight').value);
  const columns = parseInt(document.getElementById('columns').value);
  const rows = parseInt(document.getElementById('rows').value);
  const fillColor = document.getElementById('fillColor').value;
  const secondaryColor = document.getElementById('secondaryColor').value;
  const bgColor = document.getElementById('bgColor').value;
  const fillPercent = parseInt(document.getElementById('fillPercent').value);
  
  // Feature toggles
  const randomSize = document.getElementById('randomSize').checked;
  const roundedCorners = document.getElementById('roundedCorners').checked;
  const multiColor = document.getElementById('multiColor').checked;
  const applyShear = document.getElementById('applyShear').checked;
  const gradientFill = document.getElementById('gradientFill').checked;
  
  // Additional settings
  const cornerRadius = parseInt(document.getElementById('cornerRadius').value);
  const gradientStart = document.getElementById('gradientStart').value;
  const gradientEnd = document.getElementById('gradientEnd').value;
  const gradientDirection = document.getElementById('gradientDirection').value;
  
  // Set SVG dimensions and background
  svg.setAttribute('width', columns * cellWidth);
  svg.setAttribute('height', rows * cellHeight);
  svg.style.background = bgColor;
  
  // If using gradient, define the gradients
  if (gradientFill) {
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    svg.appendChild(defs);
    
    const gradient = document.createElementNS('http://www.w3.org/2000/svg', 
                     gradientDirection === 'radial' ? 'radialGradient' : 'linearGradient');
    gradient.setAttribute('id', 'cellGradient');
    
    if (gradientDirection !== 'radial') {
      // Set gradient direction
      switch(gradientDirection) {
        case 'horizontal':
          gradient.setAttribute('x1', '0%');
          gradient.setAttribute('y1', '50%');
          gradient.setAttribute('x2', '100%');
          gradient.setAttribute('y2', '50%');
          break;
        case 'vertical':
          gradient.setAttribute('x1', '50%');
          gradient.setAttribute('y1', '0%');
          gradient.setAttribute('x2', '50%');
          gradient.setAttribute('y2', '100%');
          break;
        case 'diagonal':
          gradient.setAttribute('x1', '0%');
          gradient.setAttribute('y1', '0%');
          gradient.setAttribute('x2', '100%');
          gradient.setAttribute('y2', '100%');
          break;
      }
    }
    
    // Add stops
    const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop1.setAttribute('offset', '0%');
    stop1.setAttribute('stop-color', gradientStart);
    
    const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop2.setAttribute('offset', '100%');
    stop2.setAttribute('stop-color', gradientEnd);
    
    gradient.appendChild(stop1);
    gradient.appendChild(stop2);
    defs.appendChild(gradient);
  }
  
  // Get available colors if using multiColor
  let colors = [];
  if (multiColor) {
    document.querySelectorAll('.color').forEach(color => {
      colors.push(color.getAttribute('data-color'));
    });
  }
  
  // Generate the grid cells
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < columns; x++) {
      if (Math.random() * 100 > fillPercent) continue;
      
      let width = cellWidth;
      let height = cellHeight;
      
      if (randomSize) {
        width *= 0.5 + Math.random();
        height *= 0.5 + Math.random();
      }
      
      // Determine cell color
      let color = fillColor;
      if (multiColor && colors.length > 0) {
        color = colors[Math.floor(Math.random() * colors.length)];
      }
      
      // Create the rectangle
      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute('x', x * cellWidth);
      rect.setAttribute('y', y * cellHeight);
      rect.setAttribute('width', width);
      rect.setAttribute('height', height);
      
      // Apply fill color or gradient
      if (gradientFill) {
        rect.setAttribute('fill', 'url(#cellGradient)');
      } else {
        rect.setAttribute('fill', color);
      }
      
      // Apply rounded corners if enabled
      if (roundedCorners) {
        const rx = (cornerRadius/100) * (cellWidth/2);
        const ry = (cornerRadius/100) * (cellHeight/2);
        rect.setAttribute('rx', rx);
        rect.setAttribute('ry', ry);
      }
      
      // Apply shearing if enabled
      if (applyShear) {
        const skewX = Math.random() * 20 - 10;
        const skewY = Math.random() * 20 - 10;
        rect.setAttribute('transform', `skewX(${skewX}) skewY(${skewY})`);
      }
      
      svg.appendChild(rect);
    }
  }
}

function exportSVG() {
  const svg = document.getElementById('grid');
  const serializer = new XMLSerializer();
  const source = serializer.serializeToString(svg);
  const blob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'pixflow-pattern.svg';
  link.click();
  
  // Clean up
  setTimeout(() => {
    URL.revokeObjectURL(url);
  }, 100);
}

function exportPNG() {
  const svg = document.getElementById('grid');
  const serializer = new XMLSerializer();
  const source = serializer.serializeToString(svg);
  const img = new Image();
  const svgBlob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(svgBlob);

  img.onload = function() {
    const canvas = document.createElement('canvas');
    const svgWidth = parseInt(svg.getAttribute('width'));
    const svgHeight = parseInt(svg.getAttribute('height'));
    
    canvas.width = svgWidth;
    canvas.height = svgHeight;
    
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = document.getElementById('bgColor').value;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0);
    URL.revokeObjectURL(url);

    const link = document.createElement('a');
    link.href = canvas.toDataURL('image/png');
    link.download = 'pixflow-pattern.png';
    link.click();
  };
  img.src = url;
}

function updatePercentLabel(value) {
  document.getElementById('percentLabel').innerText = value + '%';
}

function updateCornerLabel(value) {
  document.getElementById('cornerLabel').innerText = value + '%';
}

// Toggle settings panels
function toggleSettings(panelId) {
  const panel = document.getElementById(panelId);
  if (!panel) return;
  
  const isVisible = panel.style.display === 'block';
  panel.style.display = isVisible ? 'none' : 'block';
  
  // If this is the checkbox being toggled, update its label class
  const checkboxId = panelId.replace('Settings', '');
  const label = document.getElementById(checkboxId + 'Label');
  if (label) {
    if (isVisible) {
      label.classList.remove('active');
    } else {
      label.classList.add('active');
    }
  }
}

// Color presets
function applyColorPreset() {
  const preset = document.getElementById('colorPreset').value;
  const palette = document.getElementById('colorPalette');
  palette.innerHTML = '';
  
  let colors = [];
  
  switch(preset) {
    case 'retro':
      colors = ['#FF6B6B', '#4ECDC4', '#F9D423', '#FF4E50', '#556270'];
      break;
    case 'ocean':
      colors = ['#1A535C', '#4ECDC4', '#F7FFF7', '#2B7A78', '#DEF2F1'];
      break;
    case 'sunset':
      colors = ['#F9C80E', '#FF4365', '#5B2E5F', '#F15946', '#2C0835'];
      break;
    case 'forest':
      colors = ['#2D3047', '#93B7BE', '#E0CA3C', '#A37B45', '#3A5311'];
      break;
    default:
      colors = ['#ff6666', '#66aaff', '#66ff66', '#ffff66', '#ff66ff'];
  }
  
  colors.forEach(color => {
    const div = document.createElement('div');
    div.className = 'color';
    div.style.backgroundColor = color;
    div.setAttribute('data-color', color);
    div.addEventListener('click', function() {
      document.querySelectorAll('.color').forEach(c => c.classList.remove('active'));
      this.classList.add('active');
      document.getElementById('fillColor').value = this.getAttribute('data-color');
    });
    palette.appendChild(div);
  });
  
  // Set the first color as active
  if (palette.firstChild) {
    palette.firstChild.classList.add('active');
    document.getElementById('fillColor').value = colors[0];
  }
}

function getRandomColor(dark = false) {
  if (dark) {
    // Generate darker colors for background
    return '#' + Math.floor(Math.random() * 0x444444).toString(16).padStart(6, '0');
  }
  return '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
}

function generateGrid() {
  const svg = document.getElementById('grid');
  svg.innerHTML = '';
  
  // Get all the settings
  const cellWidth = parseInt(document.getElementById('cellWidth').value) || 40;
  const cellHeight = parseInt(document.getElementById('cellHeight').value) || 40;
  const columns = parseInt(document.getElementById('columns').value) || 10;
  const rows = parseInt(document.getElementById('rows').value) || 10;
  const fillColor = document.getElementById('fillColor').value;
  const secondaryColor = document.getElementById('secondaryColor').value;
  const bgColor = document.getElementById('bgColor').value;
  const fillPercent = parseInt(document.getElementById('fillPercent').value) || 50;
  
  // Feature toggles
  const randomSize = document.getElementById('randomSize').checked;
  const roundedCorners = document.getElementById('roundedCorners').checked;
  const multiColor = document.getElementById('multiColor').checked;
  const applyShear = document.getElementById('applyShear').checked;
  const gradientFill = document.getElementById('gradientFill').checked;
  
  // Additional settings
  const cornerRadius = parseInt(document.getElementById('cornerRadius').value) || 10;
  const gradientStart = document.getElementById('gradientStart')?.value || '#ff6666';
  const gradientEnd = document.getElementById('gradientEnd')?.value || '#66aaff';
  const gradientDirection = document.getElementById('gradientDirection')?.value || 'horizontal';
  
  // Set SVG dimensions and background
  svg.setAttribute('width', columns * cellWidth);
  svg.setAttribute('height', rows * cellHeight);
  svg.style.background = bgColor;
  
  // If using gradient, define the gradients
  if (gradientFill) {
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    svg.appendChild(defs);
    
    const gradient = document.createElementNS('http://www.w3.org/2000/svg', 
                     gradientDirection === 'radial' ? 'radialGradient' : 'linearGradient');
    gradient.setAttribute('id', 'cellGradient');
    
    if (gradientDirection !== 'radial') {
      // Set gradient direction
      switch(gradientDirection) {
        case 'horizontal':
          gradient.setAttribute('x1', '0%');
          gradient.setAttribute('y1', '50%');
          gradient.setAttribute('x2', '100%');
          gradient.setAttribute('y2', '50%');
          break;
        case 'vertical':
          gradient.setAttribute('x1', '50%');
          gradient.setAttribute('y1', '0%');
          gradient.setAttribute('x2', '50%');
          gradient.setAttribute('y2', '100%');
          break;
        case 'diagonal':
          gradient.setAttribute('x1', '0%');
          gradient.setAttribute('y1', '0%');
          gradient.setAttribute('x2', '100%');
          gradient.setAttribute('y2', '100%');
          break;
      }
    }
    
    // Add stops
    const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop1.setAttribute('offset', '0%');
    stop1.setAttribute('stop-color', gradientStart);
    
    const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop2.setAttribute('offset', '100%');
    stop2.setAttribute('stop-color', gradientEnd);
    
    gradient.appendChild(stop1);
    gradient.appendChild(stop2);
    defs.appendChild(gradient);
  }
  
  // Get available colors if using multiColor
  let colors = [];
  if (multiColor) {
    document.querySelectorAll('.color').forEach(color => {
      colors.push(color.getAttribute('data-color'));
    });
  }
  
  // Generate the grid cells
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < columns; x++) {
      if (Math.random() * 100 > fillPercent) continue;
      
      let width = cellWidth;
      let height = cellHeight;
      
      if (randomSize) {
        width *= 0.5 + Math.random();
        height *= 0.5 + Math.random();
      }
      
      // Determine cell color
      let color = fillColor;
      if (multiColor && colors.length > 0) {
        color = colors[Math.floor(Math.random() * colors.length)];
      }
      
      // Create the rectangle
      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute('x', x * cellWidth);
      rect.setAttribute('y', y * cellHeight);
      rect.setAttribute('width', width);
      rect.setAttribute('height', height);
      
      // Apply fill color or gradient
      if (gradientFill) {
        rect.setAttribute('fill', 'url(#cellGradient)');
      } else {
        rect.setAttribute('fill', color);
      }
      
      // Apply rounded corners if enabled
      if (roundedCorners) {
        const rx = (cornerRadius/100) * (cellWidth/2);
        const ry = (cornerRadius/100) * (cellHeight/2);
        rect.setAttribute('rx', rx);
        rect.setAttribute('ry', ry);
      }
      
      // Apply shearing if enabled
      if (applyShear) {
        const skewX = Math.random() * 20 - 10;
        const skewY = Math.random() * 20 - 10;
        rect.setAttribute('transform', `skewX(${skewX}) skewY(${skewY})`);
      }
      
      svg.appendChild(rect);
    }
  }
}

function exportSVG() {
  const svg = document.getElementById('grid');
  const serializer = new XMLSerializer();
  const source = serializer.serializeToString(svg);
  const blob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'pixflow-pattern.svg';
  link.click();
  
  // Clean up
  setTimeout(() => {
    URL.revokeObjectURL(url);
  }, 100);
}

function exportPNG() {
  const svg = document.getElementById('grid');
  const serializer = new XMLSerializer();
  const source = serializer.serializeToString(svg);
  const img = new Image();
  const svgBlob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(svgBlob);

  img.onload = function() {
    const canvas = document.createElement('canvas');
    const svgWidth = parseInt(svg.getAttribute('width'));
    const svgHeight = parseInt(svg.getAttribute('height'));
    
    canvas.width = svgWidth;
    canvas.height = svgHeight;
    
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = document.getElementById('bgColor').value;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0);
    URL.revokeObjectURL(url);

    const link = document.createElement('a');
    link.href = canvas.toDataURL('image/png');
    link.download = 'pixflow-pattern.png';
    link.click();
  };
  img.src = url;
}

function randomizeAll() {
  // Randomize dimensions
  document.getElementById('cellWidth').value = Math.floor(Math.random() * 45) + 15;
  document.getElementById('cellHeight').value = Math.floor(Math.random() * 45) + 15;
  document.getElementById('columns').value = Math.floor(Math.random() * 15) + 5;
  document.getElementById('rows').value = Math.floor(Math.random() * 15) + 5;
  
  // Randomize fill percent
  const fillPercent = Math.floor(Math.random() * 80) + 20;
  document.getElementById('fillPercent').value = fillPercent;
  updatePercentLabel(fillPercent);
  
  // Randomize colors
  document.getElementById('fillColor').value = getRandomColor();
  document.getElementById('secondaryColor').value = getRandomColor();
  document.getElementById('bgColor').value = getRandomColor(true);
  
  // Randomize features
  document.getElementById('randomSize').checked = Math.random() > 0.5;
  document.getElementById('roundedCorners').checked = Math.random() > 0.5;
  document.getElementById('multiColor').checked = Math.random() > 0.5;
  document.getElementById('applyShear').checked = Math.random() > 0.5;
  document.getElementById('gradientFill').checked = Math.random() > 0.5;
  
  // Update settings panels
  if (document.getElementById('roundedCorners').checked) {
    document.getElementById('roundedCornersSettings').style.display = 'block';
  } else {
    document.getElementById('roundedCornersSettings').style.display = 'none';
  }
  
  if (document.getElementById('multiColor').checked) {
    document.getElementById('multiColorSettings').style.display = 'block';
  } else {
    document.getElementById('multiColorSettings').style.display = 'none';
  }
  
  if (document.getElementById('gradientFill').checked) {
    document.getElementById('gradientSettings').style.display = 'block';
  } else {
    document.getElementById('gradientSettings').style.display = 'none';
  }
  
  // Update UI state
  document.querySelectorAll('.checkboxes input[type="checkbox"]').forEach(checkbox => {
    const label = checkbox.parentElement;
    if (checkbox.checked) {
      label.classList.add('active');
    } else {
      label.classList.remove('active');
    }
  });
  
  // Generate the grid
  generateGrid();
}

// Initialize UI
window.onload = function() {
  // Initialize labels
  updatePercentLabel(document.getElementById('fillPercent').value);
  updateCornerLabel(document.getElementById('cornerRadius').value);
  
  // Set up checkbox event listeners
  document.querySelectorAll('.checkboxes input[type="checkbox"]').forEach(checkbox => {
    checkbox.addEventListener('change', function() {
      const label = this.parentElement;
      if (this.checked) {
        label.classList.add('active');
      } else {
        label.classList.remove('active');
      }
      
      // For settings panels
      if (this.id === 'roundedCorners') {
        document.getElementById('roundedCornersSettings').style.display = this.checked ? 'block' : 'none';
      } else if (this.id === 'multiColor') {
        document.getElementById('multiColorSettings').style.display = this.checked ? 'block' : 'none';
      } else if (this.id === 'gradientFill') {
        document.getElementById('gradientSettings').style.display = this.checked ? 'block' : 'none';
      }
    });
  });
  
  // Set up color palette interactions
  document.querySelectorAll('.color').forEach(color => {
    color.addEventListener('click', function() {
      document.querySelectorAll('.color').forEach(c => c.classList.remove('active'));
      this.classList.add('active');
      document.getElementById('fillColor').value = this.getAttribute('data-color');
    });
  });
  
  // Generate initial grid
  generateGrid();
}
